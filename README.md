# Emberfall Ascent – Solo D&D Adventure

Emberfall Ascent is a single-player narrative RPG inspired by tabletop D&D. Build a lone hero with authentic 5e-style character creation, then guide them through a three-act campaign by describing any action you want to attempt. The client and server feed those free-form moves plus the campaign primers into Google Cloud’s Vertex AI to determine what happens next inside Emberfall’s collapsing spire.

## Campaign & Feature Highlights

- **Setting & stakes:** Emberfall is a cliffside city beneath a shattered astral spire. Each act pushes you closer to stabilising (or shattering) the Heart while the city fractures around you.
- **5e-style hero builder:** Choose a race, class, and background, allocate ability scores, pick proficiencies, and automatically derive armor class, speed, equipment, and features from shared reference data.
- **Flexible StoryCanvas:** Instead of branching buttons, type any action or line of dialogue. The StoryCanvas streams recent beats plus the campaign blueprint to Vertex AI, which returns the next narrative beat, NPC replies, and optional state updates.
- **Campaign Guide:** Sidebars summarise the key acts, characters, and lore so players remember the stakes while improvising.
- **Living log:** Every action, AI reply, and state mutation lands in the story log for transparency. Hero sheets update automatically whenever the oracle adjusts stress, flags, or allies.
- **Offline-first data:** The client bundles the campaign JSON and uses it automatically if `/api/campaign` can’t be reached. Saves fall back to browser storage whenever Firebase isn’t configured or the player skips sign-in. If the AI endpoint is offline the client generates a deterministic fallback narration so play never fully stalls.

## Tech Stack

- **Client:** React 18 + TypeScript via Vite. Context providers (`client/src/context/`) coordinate hero state, authentication, and persistence.
- **State management:** `useGameEngine` centralises character creation, free-form story beats, AI orchestration, log history, and persistence adapters (local storage or remote Firestore).
- **Server:** Express 4 (TypeScript via `ts-node-dev` during development) exposes `/api/health`, `/api/campaign`, `/api/story/advance`, and `/api/progress`. `storyEngine` builds prompts for Vertex AI (Gemini) and falls back to deterministic narration when the model is offline.
- **Shared modules:** `shared/` contains campaign data, reference tables, and types that both the client and server import directly (see the path aliases in each `tsconfig.json`).
- **Tooling:** npm workspaces, ESLint + TypeScript for the client, and a multi-stage Dockerfile targeting Node 20. GitHub Actions (`.github/workflows/build.yml`) builds the container and deploys to Cloud Run with Firebase secrets injected at build/deploy time.

## Repository Layout

```
├── client/                     # React UI (Vite + SWC)
├── server/                     # Express API, Firebase persistence, AI story engine
├── shared/                     # Campaign data + shared types
├── lessons/                    # Onboarding notes (overview, client tour, server tour)
├── .github/workflows/build.yml # Cloud Run deployment pipeline
├── .github/workflows/security-scan.yml # CodeQL + MSDO + Trivy security suite
├── Dockerfile                  # Multi-stage build (Node 20, port 8080)
├── dist/                       # Generated server + shared output (after build)
└── README.md
```

### Notable Client Components

- `CharacterCreator` – multi-step builder for race, class, background, ability scores, proficiencies, and allied hooks.
- `StoryCanvas` – streams the player’s free-form actions plus campaign anchors to the AI oracle, then renders each beat and dialogue reply.
- `CampaignGuide` & `Sidebar` – highlight the current act, characters, hero sheet, and inventory so the player always understands the state.
- `LogPanel` – chronological audit of every action, reply, and flag/status update generated by the oracle.
- `Epilogue` – surfaces act outcomes based on flags such as `heart_cleansed`, `nerrix_rescued`, or `marek_support`.

## Quick Start

```bash
# Install dependencies for the workspace (client + server)
npm install

# Terminal 1 – start the Express API on http://localhost:4000
npm run dev

# Terminal 2 – start the Vite dev server with hot reload on http://localhost:5173
npm run dev --prefix client
```

The Vite dev server proxies `/api/*` calls to the Express process. If the API isn’t reachable, the client automatically switches to the bundled campaign data and displays an “Offline mode” banner.

### Free-Form Story Workflow

1. Create a hero, then open the StoryCanvas.
2. Type anything you would attempt in a tabletop session—actions, dialogue, plans, or emotional beats.
3. The client sends the action, hero snapshot, recent beats, and the campaign blueprint to `/api/story/advance`.
4. The server’s `storyEngine` builds a structured prompt and calls Vertex AI (Gemini). The JSON reply contains the next narrative beat, NPC dialogue, and optional state deltas (status, flags, allies, notes).
5. If Vertex AI is unavailable, the server (and, as a last resort, the client) emits deterministic narrations so the player can keep moving without hard blockers.

## Vertex AI Configuration

`storyEngine` uses Google Cloud Vertex AI (Gemini) for narrative generation.

- Set the following environment variables for the **server** process (local `.env`, Docker args, Cloud Run, etc.):
  - `GENAI_PROJECT_ID`: Google Cloud project that hosts Vertex AI (defaults to `FIREBASE_PROJECT_ID` if omitted).
  - `GENAI_LOCATION`: Vertex AI region (defaults to `us-central1`).
  - `GENAI_MODEL`: Model name, e.g., `gemini-1.5-pro`.
  - `GENAI_RATE_LIMIT_WINDOW_MS` *(optional)*: override the in-process rate-limit window (default 60 s).  
  - `GENAI_RATE_LIMIT_MAX_CALLS` *(optional)*: override how many Vertex requests may occur within the window (default 40).
- Provide credentials via Application Default Credentials (recommended for Cloud Run) or by pointing `GOOGLE_APPLICATION_CREDENTIALS` to a service-account JSON. The same service account can also drive Firebase Admin by storing its JSON (or base64) in `FIREBASE_SERVICE_ACCOUNT`.
- These variables are consumed inside `server/src/lib/storyEngine.ts`: the prompt builder reads the campaign blueprint, and `generateStoryBeat` invokes Vertex AI with the configured project/model while the in-process limiter ensures you never exceed your quota. The endpoint `/api/story/advance` wires player actions → story beats via that helper.
- When the env vars or credentials are missing, the server instantly falls back to deterministic narration, so local development works without cloud access.
- `/api/story/advance` only sends the last few beats, the hero snapshot, and the campaign blueprint—no player account identifiers are shared with the model.

## Core Scripts

| Command | Description |
| --- | --- |
| `npm run dev` | Launches the TypeScript Express server with `ts-node-dev` (port 4000 by default). |
| `npm run dev --prefix client` | Starts the Vite dev server (port 5173). |
| `npm run build` | Builds the client (Vite) and server (TypeScript) into `dist/`. |
| `npm run start` | Runs the compiled Express server from `dist/server/src/index.js`; also serves `client/dist`. |
| `npm run lint` | Delegates to the client’s ESLint configuration. |
| `npm run build --prefix client` / `npm run build --prefix server` | Run the build steps individually when needed. |

## Firebase Authentication & Cloud Saves

The client uses Firebase Authentication (Email/Password) and calls `/api/progress` with a bearer token. The server verifies tokens via the Firebase Admin SDK and persists the hero state per user in Firestore. When auth isn’t configured or the player taps “Continue without an account,” the client stays in guest mode and uses `localStorage` (`emberfall-ascent-save-v3`).

1. **Client SDK config:** create `client/.env` (or `.env.local`) with your Firebase web app keys.
   ```bash
   VITE_FIREBASE_API_KEY=your-api-key
   VITE_FIREBASE_AUTH_DOMAIN=your-project.firebaseapp.com
   VITE_FIREBASE_PROJECT_ID=your-project-id
   VITE_FIREBASE_STORAGE_BUCKET=your-project.appspot.com
   VITE_FIREBASE_MESSAGING_SENDER_ID=1234567890
   VITE_FIREBASE_APP_ID=1:1234567890:web:abcdef
   ```
2. **Server credentials:** supply the Admin SDK JSON by either
   - setting `FIREBASE_SERVICE_ACCOUNT` to the raw JSON (or a base64-encoded string, which is how CI passes it),
   - pointing `GOOGLE_APPLICATION_CREDENTIALS` at a JSON file, or
   - dropping `server/firebase-service-account.local.json` with the key contents (auto-loaded in development).
   If your JSON is missing `project_id`, also set `FIREBASE_PROJECT_ID`.
3. **Optional overrides:** `FIREBASE_PROGRESS_COLLECTION` (defaults to `gameProgress`) controls the Firestore collection the progress router uses.

## Persistence & API Surface

- `/api/health` – simple health probe (used by Cloud Run & local diagnostics).
- `/api/campaign` – returns the authoritative campaign JSON sourced from `shared/campaign.ts`.
- `/api/oracle` – accepts `{ npcId, prompt, hero }` and produces deterministic NPC replies that incorporate flags, stress, wounds, influence, and corruption.
- `/api/progress` – protected by Firebase ID tokens. Supports `GET` (load), `POST` (save), and `DELETE` (clear).

When Firebase isn’t available, the middleware short-circuits with `503`, and the client remains in guest/local-storage mode. The in-app **Reset Save** button clears both local and remote persistence.

## Building & Deployment

```bash
# Build both apps into dist/
npm run build

# Serve the bundled client + API from dist/ (port 4000 by default)
npm start
```

### Docker

```bash
# Build the multi-stage image (needs the VITE_* client secrets)
cat <<'EOF' > firebase.build.env
VITE_FIREBASE_API_KEY=...
VITE_FIREBASE_AUTH_DOMAIN=...
VITE_FIREBASE_PROJECT_ID=...
VITE_FIREBASE_STORAGE_BUCKET=...
VITE_FIREBASE_MESSAGING_SENDER_ID=...
VITE_FIREBASE_APP_ID=...
EOF

DOCKER_BUILDKIT=1 docker build -t emberfall-ascent \
  --secret id=vite_client_env,src=firebase.build.env \
  .

# Run locally on port 8080 (matches Cloud Run/App Engine defaults)
docker run -p 8080:8080 emberfall-ascent
```

The Dockerfile never bakes Firebase secrets into layers. Instead, it expects a BuildKit secret (`vite_client_env`) that mirrors the contents of `client/.env`. When building locally, supply a file with all `VITE_*` values as shown above. The `build.yml` workflow generates the same payload from GitHub secrets and passes it via `--secret id=vite_client_env,env=CLIENT_ENV`.

### Cloud Run pipeline

`.github/workflows/build.yml` authenticates via Workload Identity, builds the Docker image, pushes it to Artifact Registry, and deploys to Cloud Run (`CLOUD_RUN_SERVICE=dnd`). Secrets provide the `VITE_*` build arguments plus the service-account JSON (base64-encoded) for the runtime environment variables `FIREBASE_SERVICE_ACCOUNT`, `FIREBASE_PROJECT_ID`, and the Vertex AI configuration (`GENAI_PROJECT_ID`, `GENAI_LOCATION`, `GENAI_MODEL`).

## Testing & Manual Verification

1. Run both dev servers (`npm run dev` and `npm run dev --prefix client`) and open `http://localhost:5173`.
2. Create a hero, submit a variety of free-form actions, and observe that Vertex AI (or the deterministic fallback) returns beats that update hero flags/status when appropriate.
3. Stop the server to confirm the client logs the offline fallback narration, then restart and ensure `/api/story/advance` resumes normal responses.
4. Toggle guest mode vs. Firebase-authenticated mode to confirm saves land in local storage or Firestore (`/api/progress` endpoints return `2xx`).
5. Use **Reset Save** to ensure state clears both locally and remotely.

## Additional Notes

- Status values are clamped and validated on the client before persistence, reducing corrupt save data.
- Shared types (`shared/types.ts`) are part of both TypeScript build graphs, so breaking changes surface at compile time.
- The `lessons/` folder contains guided tours of the codebase (overview, client tour, and server tour) if you need a refresher.

## Security Automation

- `.github/workflows/security-scan.yml` runs on every push, PR, and the weekly cron.
  - **CodeQL Suite:** single job that scans the JavaScript/TypeScript codebase and GitHub Actions workflow definitions.
  - **Microsoft Security DevOps:** executes CredScan (needs.NET 6) and Checkov with SARIF uploads to the GitHub Security tab.
  - **Trivy Scan:** builds the Docker image from this repo and publishes container vulnerability findings back to GitHub.
- `.github/workflows/build.yml` remains focused on Cloud Run deployment but now declares only the minimum permissions required to satisfy Checkov gatekeepers.
